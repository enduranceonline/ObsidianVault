#apuntes #certificacion #eJPT
# 1) ðŸ§­ EnumeraciÃ³n interna (post-explotaciÃ³n)

## Objetivo

Mapear el sistema comprometido para: **(1) credenciales**, **(2) privilegios**, **(3) red/pivot**, **(4) servicios/datos sensibles**.

---

## ðŸ§ Linux

###  ðŸ”¹Info bÃ¡sica

```bash
whoami; id
uname -a
cat /etc/os-release
hostnamectl
```

### ðŸ”¹Usuarios y homes

```bash
cat /etc/passwd | cut -d: -f1
ls -la /home
```

>**Busca:** UID 0, shells vÃ¡lidas, homes interesantes.

### ðŸ”¹Credenciales y secretos

```bash
ls -la ~/.ssh
grep -R -nI "password|passwd|secret|token|api_key|aws_access" /home /etc 2>/dev/null
find / -name "*.pem" -o -name "*.key" 2>/dev/null
```

>**Sitios tÃ­picos:** `~/.ssh`, `.env`, `config.php`, repos `.git`, backups `.bak`.

### ðŸ”¹Privilegios / abusos

```bash
sudo -l
find / -perm -4000 -type f 2>/dev/null     # SUID
getcap -r / 2>/dev/null                    # capacidades
```

### ðŸ”¹Servicios / puertos / procesos

```bash
ss -tulnp
ps aux --sort=-%mem | head
systemctl list-units --type service --state running
```

### ðŸ”¹Paquetes / versiones

```bash
dpkg -l | less      # Debian/Ubuntu
rpm -qa | less      # RHEL/CentOS
```

### ðŸ”¹Red y pivot

```bash
ip addr; ip route
arp -a
```

>**SeÃ±ales de pivot:** interfaces internas, rutas a otras subredes.

### ðŸ”¹Contenedores / virtualizaciÃ³n

```bash
docker ps -a
[ -S /var/run/docker.sock ] && echo "docker.sock presente"
```

### ðŸ”¹Cron / persistencia

```bash
crontab -l
ls -la /etc/cron* /var/spool/cron
```

### ðŸ”¹Logs (intel rÃ¡pida)

```bash
journalctl -n 200 --no-pager || tail -n 200 /var/log/syslog
```

---

## ðŸªŸ Windows (PowerShell)

### ðŸ”¹Info bÃ¡sica

```powershell
whoami
systeminfo
Get-ComputerInfo | Select CsName,OsName,WindowsVersion,OsBuildNumber
```

### ðŸ”¹Usuarios / grupos

```powershell
Get-LocalUser
Get-LocalGroupMember -Group "Administrators"
```

### ðŸ”¹Credenciales / ficheros

```powershell
dir C:\Users\ -Force
Get-ChildItem C:\ -Recurse -ErrorAction SilentlyContinue -Include *.config,*.xml,*.ps1,*.env,appsettings.json
```

### ðŸ”¹Servicios / puertos / procesos

```powershell
Get-Service | ? {$_.Status -eq "Running"}
netstat -ano
Get-Process
```

### ðŸ”¹Parches / hotfixes

```powershell
Get-HotFix | Sort InstalledOn -Descending | Select -First 50
```

### ðŸ”¹Red y rutas

```powershell
ipconfig /all
Get-NetRoute
arp -a
```

### ðŸ”¹Tareas / persistencia

```powershell
schtasks /query /fo LIST /v
```

---

## Prioridad operativa (orden sugerido)

1. **Contexto**: `whoami`, `id` / `systeminfo`
2. **Privilegios**: `sudo -l` / grupo Administrators
3. **Credenciales**: `~/.ssh`, `.env`, `config.php`, `*.key`
4. **Servicios/puertos**: `ss -tulnp` / `netstat -ano`
5. **Red/pivot**: `ip addr` / `ipconfig`
6. **SUID/caps/cron** (Linux) / **tareas** (Windows)
7. **Logs** para pistas.

---

## ðŸ‘‰Checklist ultrarrÃ¡pida (copiar/pegar)

ðŸ”¹**Linux**

```bash
whoami; id; uname -a
sudo -l
ss -tulnp
grep -R -nI "password|token|secret" /home /etc 2>/dev/null
ls -la ~/.ssh
find / -perm -4000 -type f 2>/dev/null
getcap -r / 2>/dev/null
ip addr; ip route
journalctl -n 200 --no-pager
```

ðŸ”¹**Windows (PS)**

```powershell
whoami; systeminfo
Get-LocalUser
Get-LocalGroupMember -Group Administrators
Get-Service | ? {$_.Status -eq "Running"}
netstat -ano
ipconfig /all
Get-HotFix | Select HotFixID,InstalledOn
```

---

# 2) ðŸ” Cracking de contraseÃ±as (offline)

## Conceptos clave

- **Hash**: huella unidireccional de la contraseÃ±a (no reversible).

- **Inseguros (rÃ¡pidos)**: **MD5**, **SHA1** â†’ fÃ¡ciles con diccionarios/GPU.

- **Recomendados (lentos + salt + iteraciones)**: **bcrypt**, **scrypt**, **Argon2**, **PBKDF2**.


### ðŸ”¹Salt (lo esencial para eJPTv2)

- **QuÃ© es**: valor aleatorio **por usuario** concatenado antes de hashear.

- **Para quÃ© sirve**: evita rainbow tables y que dos contraseÃ±as iguales den el mismo hash.

- **No es secreto** (se almacena junto al hash).

- **LimitaciÃ³n**: con algoritmos rÃ¡pidos (MD5/SHA1) **sigue** siendo crackeable por diccionario/GPU.


**Reconocer formatos**

- `NTLM` (sin salt) â†’ 32 hex (tipo MD5-like) pero distinto algoritmo.

- `MD5crypt`: `$1$salt$hash`

- `SHA512-crypt`: `$6$salt$hash`

- `bcrypt`: `$2y$cost$salt...hash...`


## Tipos de ataque

1. **Diccionario** (primero en eJPT): `rockyou.txt`, listas de Metasploit.

2. **Reglas** (append 1!, capitalizar, leetspeak).

3. **Mascara** (si conoces patrÃ³n).

4. **Fuerza bruta total** (solo si muy corto).


## Herramientas y comandos mÃ­nimos

### ðŸ”¹John the Ripper

```bash
# Linux shadow
sudo unshadow /etc/passwd /etc/shadow > shadow.txt
john --wordlist=/usr/share/wordlists/rockyou.txt shadow.txt
john --show shadow.txt
```

### ðŸ”¹Hashcat (cuando necesites modo especÃ­fico o GPU)

```bash
# NTLM (m=1000)
hashcat -m 1000 -a 0 hashes.txt /usr/share/wordlists/rockyou.txt
# bcrypt (m=3200)
hashcat -m 3200 -a 0 hashes.txt /usr/share/wordlists/rockyou.txt
```

**Identificar hash**: `hashid`, `john --list=formats`, `hashcat --help`.

## Flujo recomendado en examen

1. Identifica formato (longitud/prefijo).
    
2. **Diccionario** con `rockyou.txt`.
    
3. Si no sale y es _salted+iterativo_ (bcrypt/Argon2): **documenta** por quÃ© es costoso.
    
4. Si es _unsalted_ (NTLM/MD5) prueba reglas simples o mÃ¡scara.

---
# 3) ðŸ” Cracking de contraseÃ±as â€” Herramientas y flujo prÃ¡ctico

> **Idea clave:** el cracking es **offline**. Una vez obtienes el **hash**, lo procesas en tu Kali (sin tocar la mÃ¡quina vÃ­ctima). En el examen prima usar **diccionarios** (p. ej. `rockyou.txt`) y reconocer el **tipo de hash**.

## 1) Identificar el tipo de hash

### ðŸ”¹Utilidades

- `hashid` (CLI simple)
```bash
hashid '5f4dcc3b5aa765d61d8327deb882cf99'  # entrada en lÃ­nea
hashid hash.txt                            # fichero con hashes
```

- `hash-identifier` (interactivo, similar)

**QuÃ© mirar:** longitud (MD5=32 hex, SHA1=40, SHA256=64, NTLM=32), prefijos con dÃ³lares (p. ej. `$6$...` = SHA512-crypt con **salt**), formatos tipo bcrypt `$2y$12$...`.

> Si el hash parece **unsalted** (MD5/NTLM crudo), el diccionario suele funcionar muy bien. Si es **bcrypt/PBKDF2/Argon2**, documenta el tipo y prueba diccionario, pero asume que puede no ser viable por tiempo.

## 2) Diccionarios recomendados (Kali)

```bash
# principal
/usr/share/wordlists/rockyou.txt  # descomprime si estÃ¡ .gz

# otros Ãºtiles
/usr/share/wordlists/metasploit/unix_passwords.txt
/usr/share/wordlists/metasploit/unix_users.txt
/usr/share/wordlists/wfuzz/others/common_pass.txt
/usr/share/wordlists/seclists/Passwords/2023-200_most_used_passwords.txt
```

> **Diccionario > fuerza bruta** para eJPT. La fuerza bruta pura es lenta; usa reglas/mÃ¡scaras solo si tienes pistas.

## 3) John the Ripper (rÃ¡pido y â€œautoâ€)

### ðŸ”¹Uso bÃ¡sico

```bash
# Linux: combinar /etc/passwd + /etc/shadow si los tienes
unshadow /etc/passwd /etc/shadow > shadow_unified
john --wordlist=/usr/share/wordlists/rockyou.txt shadow_unified

# Hash suelto (John suele autodetectar el formato)
john --wordlist=/usr/share/wordlists/rockyou.txt hash.txt

# NT/NTLM de Windows (forzar formato si lo conoces)
john --format=NT --wordlist=/usr/share/wordlists/rockyou.txt ntlm.txt

# Mostrar resultados descifrados
john --show hash.txt
```

### ðŸ”¹Consejos

- John **autodetecta** muchos formatos, incluido **salt** incrustado.
    
- Si no detecta, prueba `--format=<FORMATO>` (NT, raw-md5, bcrypt, etc.).
    
- Puedes activar reglas de transformaciÃ³n: `--rules`.

## 4) Hashcat (potente, requiere modo `-m`)

### ðŸ”¹AutodetecciÃ³n (para decidir el modo)

```bash
# Lanza en "autodetect" sin crackear realmente; te sugiere modos vÃ¡lidos
hashcat hash.txt /usr/share/wordlists/rockyou.txt
# VerÃ¡s algo como:
# 100 | SHA1 | Raw Hash
# 1000 | NTLM | Raw Hash
# 3200 | bcrypt | Raw Hash salted and/or iterated
# ...
```

Hashcat te pedirÃ¡ que **especifiques el modo** con `-m`. Elige el id coherente con lo que dijo `hashid`/`hash-identifier` y/o por longitud/formato.

### ðŸ”¹Ataque por diccionario (lo normal en eJPT)

```bash
# NTLM (Windows)
hashcat -m 1000 -a 0 ntlm.txt /usr/share/wordlists/rockyou.txt

# MD5 crudo
hashcat -m 0 -a 0 md5.txt /usr/share/wordlists/rockyou.txt

# SHA1 crudo
hashcat -m 100 -a 0 sha1.txt /usr/share/wordlists/rockyou.txt

# bcrypt (lento; puede no ser viable en examen)
hashcat -m 3200 -a 0 bcrypt.txt /usr/share/wordlists/rockyou.txt
```

### ðŸ”¹Variantes Ãºtiles

```bash
# Reglas (transformaciones tÃ­picas; acelera sin pasar a brute force)
hashcat -m 1000 -a 0 ntlm.txt rockyou.txt -r /usr/share/hashcat/rules/best64.rule

# MÃ¡scara (si tienes patrÃ³n: ej. 3 letras + 3 dÃ­gitos)
hashcat -m 0 -a 3 md5.txt ?l?l?l?d?d?d
```

> Evita **-a 3** (brute-force/mÃ¡scara) salvo que tengas una mÃ¡scara **concretÃ­sima**. Si no, se dispara el tiempo.

---

## 5) Salt, iteraciones y expectativas

- **Salt** por usuario â†’ cada hash se ataca **individualmente**; rainbow tables inutilizadas.
    
- **Iteraciones**/algoritmos â€œlentosâ€ (bcrypt/PBKDF2/Argon2) â†’ cada intento cuesta mÃ¡s; puede no ser crackeable en tiempo razonable.
    
- En eJPT: **reconoce el formato**, intenta diccionario y **documenta** por quÃ© no progresa si es un esquema fuerte.
    

---

## ðŸ‘‰ 6) Flujo recomendado (paso a paso)

1. **Identifica** con `hashid` / `hash-identifier` y por **formato/longitud**.
    
2. **Prueba John** con `rockyou.txt`.
    
3. Si falla o quieres afinar, usa **Hashcat**: ejecuta autodetecciÃ³n, elige **`-m`** correcto y corre diccionario.
    
4. Si tienes **pistas** (estructura de la contraseÃ±a), aÃ±ade **reglas** o una **mÃ¡scara**.
    
5. **Anota resultados** (contraseÃ±as crackeadas, tiempo, mÃ©todo) para el informe.
    

---

## ðŸ‘‰ 7) Mini-chuleta (copiar/pegar)

```bash
# Identificar
hashid hash.txt
hash-identifier

# John bÃ¡sico
john --wordlist=/usr/share/wordlists/rockyou.txt hash.txt
john --format=NT --wordlist=/usr/share/wordlists/rockyou.txt ntlm.txt
john --show hash.txt

# Hashcat: autodetect + elegir -m
hashcat hash.txt /usr/share/wordlists/rockyou.txt
# luego:
hashcat -m 1000 -a 0 ntlm.txt /usr/share/wordlists/rockyou.txt
hashcat -m 0 -a 0 md5.txt /usr/share/wordlists/rockyou.txt
hashcat -m 100 -a 0 sha1.txt /usr/share/wordlists/rockyou.txt
# con reglas
hashcat -m 1000 -a 0 ntlm.txt rockyou.txt -r /usr/share/hashcat/rules/best64.rule
```

---

## 8) Ejercicio prÃ¡ctico (5â€“10 min)

1. Toma un hash NTLM (ejemplo, en `ntlm.txt`).
    
2. IdentifÃ­calo: `hashid ntlm.txt` (deberÃ­a sugerir NTLM).
    
3. Cracking con John:
    

```bash
john --format=NT --wordlist=/usr/share/wordlists/rockyou.txt ntlm.txt
john --show ntlm.txt
```

4. Repite con Hashcat:
    

```bash
hashcat -m 1000 -a 0 ntlm.txt /usr/share/wordlists/rockyou.txt
```

5. Si no sale, aÃ±ade reglas (`best64.rule`). Documenta el resultado.
    

---

### ðŸ”¹Tips finales eJPTv2

- **Offline siempre**: no necesitas conexiÃ³n a la vÃ­ctima para crackear hashes.
    
- **Diccionario primero** (rockyou + reglas), **mÃ¡scaras** solo con patrÃ³n.
    
- **Reconoce el formato** y el **salt**; ajusta expectativas para bcrypt/PBKDF2/Argon2.
    
- Guarda comandos y **salidas** para el informe: demuestra mÃ©todo y razonamiento.

---

# 4) ðŸ› ï¸ Fuerza bruta online (muy breve)

- **Hydra** para SSH/HTTP/FTP/SMB.
    
- **Metasploit** (auxiliary): `scanner/ssh/ssh_login`, `scanner/ftp/ftp_login`, `scanner/smb/smb_login`.

## **Hydra ejemplos**

```bash
# SSH
hydra -L users.txt -P passwords.txt ssh://IP
# HTTP POST (necesitas ruta y cadena correcta)
hydra -l admin -P /usr/share/wordlists/rockyou.txt IP http-post-form \
"/login.php:username=^USER^&password=^PASS^:Login failed"
# SMB
hydra -L users.txt -P passwords.txt IP smb
```

> No abuses fuerza bruta: usa **diccionarios pequeÃ±os** y **pistas** de enumeraciÃ³n previa.

---

# 5) ðŸ§¾ Recordatorio final (eJPTv2)

- Prioriza **credenciales â†’ privilegios â†’ red/pivot**.
    
- En cracking, **diccionario primero**; identifica **salt/algoritmo** y **justifica** si no es viable.
    
- Ten localizados los wordlists:  
    `/usr/share/wordlists/rockyou.txt`, `/usr/share/wordlists/metasploit/*`, `/usr/share/wordlists/wfuzz/others/common_pass.txt`.
    
- Usa Hydra/Metasploit solo cuando la enumeraciÃ³n sugiera credenciales probables.